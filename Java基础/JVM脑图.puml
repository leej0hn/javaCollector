@startmindmap
+ JVM
++ 内存结构
+++ 线程共享区域
++++ 堆
+++++ 新生代
++++++ Eden区
++++++ Survivor(from)区
+++++++ 设置Survivor是为了减少送到老年代的对象
++++++ Survivor(to)区
+++++++ 设置两个Survivor区是为了解决碎片化的问题
++++++ eden:survivor:survivor8:1:1
+++++ 老年代
++++++ 老年代：新生代=2:1
++++ 方法区
+++++ 运行时常量
++++++ Class 文件中的常量池(编译器生成的各种字面量和符号引用)会在类加载后被放入这个区域
++++++ 存储信息
+++++++ 符号引用
++++++++ 符号引用包含的常量
+++++++++ 类符号引用
+++++++++ 方法符号引用
+++++++++ 字段符号引用
++++++++ 概念解释
*********: 一个java类（假设为People类）被编译成一个class文件时，
如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，
因此只能使用符号引用来代替。;
*********: 而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，
因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。;
*********: 即在编译时用符号引用来代替引用类，
在加载时再通过虚拟机获取该引用类的实际地址。;
*********: 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，
只要使用时能无歧义地定位到目标即可。
符号引用与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。;
+++++++ 字面量
++++++++ 文字字符串
+++++++++ String a = "abc", 这个abc就是字面量
++++++++ 八种基本类型
+++++++++ int a = 1; 这个1就是字面量
++++++++ 声明为final的常量
+++++ 静态变量
+++++ final类型常量
+++++ 类信息
++++++ 类的完整有效名
++++++ 返回值类型
++++++ 修饰符(public, private...)
++++++ 变量名
++++++ 方法名
++++++ 方法代码
******: 这个类型直接父类的完整有效名
(除非这个类型是interface或是java.lang.Object,这两种情况都没有父类);
++++++ 类的直接接口的一个有序列表
+++ 线程私有区域
++++ 虚拟机栈
+++++ 栈帧
++++++ 动态链接
+++++++ 符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接
+++++++ 前提是每个栈帧内部都要包含一个指向运行时常量池的引用，来支持动态链接的实现
++++++ 操作数栈
+++++++ 保存着Java虚拟机执行过程中的数据
++++++ 局部变量表
*******: 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，
这个方法需要在帧中分配多大的局部变量空间是完全确定的，
在方法运行期间不会改变局部变量表的大小。;
+++++++ 存放的信息
++++++++ 基本数据类型
++++++++ 对象引用
++++++++ returnAddress类型
++++++ 方法返回地址
+++++++ 方法被调用的位置
+++++++ 方法退出的过程实际上就等同于把当前栈帧出栈
+++++++ 方法退出可能包含的操作
++++++++ 恢复上层方法的局部变量表和操作数栈
++++++++ 把返回值(如果有的话)压入调用者栈的操作数栈中
++++++++ 调整PC计数器的值以指向方法调用指令后面的一条指令
+++++ 异常
++++++ 线程请求的栈深度大于虚拟机所允许的深度
+++++++ StackOverflowError
++++++ JVM动态扩展时无法申请到足够的内存时
+++++++ OutOfMemoryError
*****: 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，
并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，
不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。;
++++ 本地方法栈
+++++ 和虚拟机栈类似，区别是本地方法栈使用到的Native方法服务
++++ 程序计数器
+++++ 如果线程正在执行的是一个Java方法，则指明当前线程执行的代字节码行数
+++++ 此内存区域是唯一一个不会出现OutOfMemoryError情况的区域
+++++ 如果正在执行的是Native方法，这个计数器值则为空(Undefined)
++++ 上述三个区域的生命周期和线程相同
+++ 直接内存
++++ 使用Native函数库直接分配堆外内存
++++ 并不是JVM运行时数据区域的一部分，但是会被频繁使用
++++ 避免了在Java堆和Native堆中来回复制数据，提高效率
++ 垃圾回收
+++ 对象是否存在
++++ 引用计数法
*****: 给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。
引用计数为0的对象可被回收;
+++++ 缺陷：循环引用会导致内存泄漏
++++ 可达性分析算法
*****: 该算法是通过一系列的称为“GC Roots”的对象作为起始点,
从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),
当一个对象到GC Roots没有任何引用链相连
(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。;
+++++ GC Roots
++++++ 当前虚拟机栈中局部变量表中的引用的对象
++++++ 当前本地方法栈中局部变量表中的引用的对象
++++++ 方法区中类静态属性引用的对象
++++++ 方法区中的常量引用的对象
++++ 判断一个对象是否可回收的过程(两步)
+++++ 1 找到GC Roots不可达的对象，如果没有重写finalize()或者调用过finalize(),则将该对象加入到F-Queue中
+++++ 2 再次进行标记，如果此时对象还未与GC Roots建立引用关系，则被回收
+++ 回收对象引用类型
++++ 强引用
+++++ 垃圾回收器绝对不会回收它，当内存不足时宁愿抛出OOM错误，使得程序异常停止
++++ 软引用
+++++ 垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收它
+++++ 软引用非常适合创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。
++++ 弱引用
+++++ 垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。ThreadLocal的key是弱引用
++++ 虚引用
+++++ 如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。
+++++ 虚引用主要用来跟踪对象被垃圾回收器回收的活动
+++ 垃圾收集算法
++++ 标记-清除
+++++ 过程
++++++ 1. 将需要回收的对象标记起来
++++++ 2. 清除对象
+++++ 缺陷
++++++ 1. 标记和清除的效率都不高
++++++ 2. 产生大量的不连续的内存碎片
++++ 复制算法
*****: 复制算法是将内存划分为两块大小相等的区域，每次使用时都只用其中一块区域，
当发生垃圾回收时会将存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。;
+++++ 新生代使用的是复制算法
+++++ 优点
++++++ 简单高效，不会出现内存碎片问题
+++++ 缺陷
++++++ 内存利用率低
++++++ 存活对象较多时效率明显会降低
++++ 标记整理
*****: 原理和标记清除算法类似，只是最后一步的清除改为了将存活的
对象全部移动到一端，然后再将边界之外的内存全部回收。;
+++++ 老年代使用的是标记-整理算法
+++++ 缺陷
++++++ 需要移动大量对象，效率不高
++++ 分代回收算法
+++++ 根据各个年代的特点选取不同的垃圾收集算法
+++++ 新生代使用复制算法
+++++ 老年代使用标记-整理或者标记-清除算法
+++ 垃圾收集器
++++ Serial收集器
+++++ 串行单线程收集器
+++++ 优点：简单高效
+++++ 是Client模式下的默认新生代收集器
++++ ParNew收集器
+++++ Serial收集器的多线程版本
*****: 是Server模式下的虚拟机首选新生代收集器，除了性能原因外，
主要是因为除了Serial收集器，只有它能与CMS收集器配合工作。
;
++++ Parallel Scavenge收集器
+++++ 多线程收集器
+++++ “吞吐量优先”收集器，更加关注系统的吞吐量
+++++ 适合在后台运算而不需要太多交互的任务
++++ Serial Old收集器
+++++ Serial收集器的老年代版本
+++++ 可用于Client模式下
+++++ 用于Server模式下时
++++++ 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用
++++++ 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。
++++ ParNew Old收集器
+++++ Parallel Scavenge收集器的老年代版本
+++++ 注重程序吞吐量
++++ CMS收集器
+++++ 流程
++++++ 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿（STW）
++++++ 并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。
++++++ 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)
++++++ 并发清除：不需要停顿。
+++++ 缺陷
++++++ 吞吐量低
+++++++ 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高
++++++ 无法处理浮动垃圾，可能出现 Concurrent Mode Failure
+++++++ 浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收
+++++++ 由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。
+++++++ 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS
++++++ 会产生空间碎片
+++++++ 标记-清除算法会导致产生不连续的空间碎片
++++ G1收集器
+++++ G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。
+++++ 流程
******: 初始标记：仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，
让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短。;
******: 并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，
此阶段耗时较长，但可与用户程序并发执行。;
******: 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，
虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，
最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。
这阶段需要停顿线程(STW)，但是可并行执行。;
******: 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。
此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，
时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。;
+++++ 特点
++++++ 空间整合，不会产生内存碎片
++++++ 可预测的停顿
+++++ 参数设置
++++++ -XX:+UseG1GC
++++++ -XX:MaxGCPauseMillis
++ 类加载机制
++ class文件结构
-- 对象
-- 内存相关
-- 其他知识
-- JVM调优
@endmindmap