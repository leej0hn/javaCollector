@startmindmap
+ JVM
++ 内存结构
+++ 线程共享区域
++++ 堆
+++++ 新生代
++++++ Eden区
++++++ Survivor(from)区
+++++++ 设置Survivor是为了减少送到老年代的对象
++++++ Survivor(to)区
+++++++ 设置两个Survivor区是为了解决碎片化的问题
++++++ eden:survivor:survivor8:1:1
+++++ 老年代
++++++ 老年代：新生代=2:1
++++ 方法区
+++++ 运行时常量
++++++ Class 文件中的常量池(编译器生成的各种字面量和符号引用)会在类加载后被放入这个区域
++++++ 存储信息
+++++++ 符号引用
++++++++ 符号引用包含的常量
+++++++++ 类符号引用
+++++++++ 方法符号引用
+++++++++ 字段符号引用
++++++++ 概念解释
*********: 一个java类（假设为People类）被编译成一个class文件时，
如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，
因此只能使用符号引用来代替。;
*********: 而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，
因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。;
*********: 即在编译时用符号引用来代替引用类，
在加载时再通过虚拟机获取该引用类的实际地址。;
*********: 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，
只要使用时能无歧义地定位到目标即可。
符号引用与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。;
+++++++ 字面量
++++++++ 文字字符串
+++++++++ String a = "abc", 这个abc就是字面量
++++++++ 八种基本类型
+++++++++ int a = 1; 这个1就是字面量
++++++++ 声明为final的常量
+++++ 静态变量
+++++ final类型常量
+++++ 类信息
++++++ 类的完整有效名
++++++ 返回值类型
++++++ 修饰符(public, private...)
++++++ 变量名
++++++ 方法名
++++++ 方法代码
******: 这个类型直接父类的完整有效名
(除非这个类型是interface或是java.lang.Object,这两种情况都没有父类);
++++++ 类的直接接口的一个有序列表
+++ 线程私有区域
++++ 虚拟机栈
+++++ 栈帧
++++++ 动态链接
+++++++ 符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接
+++++++ 前提是每个栈帧内部都要包含一个指向运行时常量池的引用，来支持动态链接的实现
++++++ 操作数栈
+++++++ 保存着Java虚拟机执行过程中的数据
++++++ 局部变量表
*******: 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，
这个方法需要在帧中分配多大的局部变量空间是完全确定的，
在方法运行期间不会改变局部变量表的大小。;
+++++++ 存放的信息
++++++++ 基本数据类型
++++++++ 对象引用
++++++++ returnAddress类型
++++++ 方法返回地址
+++++++ 方法被调用的位置
+++++++ 方法退出的过程实际上就等同于把当前栈帧出栈
+++++++ 方法退出可能包含的操作
++++++++ 恢复上层方法的局部变量表和操作数栈
++++++++ 把返回值(如果有的话)压入调用者栈的操作数栈中
++++++++ 调整PC计数器的值以指向方法调用指令后面的一条指令
+++++ 异常
++++++ 线程请求的栈深度大于虚拟机所允许的深度
+++++++ StackOverflowError
++++++ JVM动态扩展时无法申请到足够的内存时
+++++++ OutOfMemoryError
*****: 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，
并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，
不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。;
++++ 本地方法栈
+++++ 和虚拟机栈类似，区别是本地方法栈使用到的Native方法服务
++++ 程序计数器
+++++ 如果线程正在执行的是一个Java方法，则指明当前线程执行的代字节码行数
+++++ 此内存区域是唯一一个不会出现OutOfMemoryError情况的区域
+++++ 如果正在执行的是Native方法，这个计数器值则为空(Undefined)
++++ 上述三个区域的生命周期和线程相同
+++ 直接内存
++++ 使用Native函数库直接分配堆外内存
++++ 并不是JVM运行时数据区域的一部分，但是会被频繁使用
++++ 避免了在Java堆和Native堆中来回复制数据，提高效率
++ 内存回收
++ 类加载机制
++ class文件结构
-- 对象
-- 内存相关
-- 其他知识
-- JVM调优
@endmindmap